#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.

#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <https://www.gnu.org/licenses/>.

import sys
import os
import tempfile
import shutil
import re
import logging

try:
    from configparser import ConfigParser as confparser
except ImportError:
    from ConfigParser import ConfigParser as confparser

try:
    import pygit2
except:
    print("Could not find the pygit2 package")
    sys.exit(1)

_DEFAULT_PATH = os.path.expanduser("~/.gitcheckver/config")

_DEFAULT_CONFIG = {
        "repo_list": "~/.gitcheckver/repolist.cfg"
    }

class gitcheckver(object):

    def __init__(self, confpath=_DEFAULT_PATH, verbose=logging.INFO):

        # initiate logging
        self.log = self.get_log("gitcheckver", verbose)

        # initiate and read general configuration
        self.confpath = os.path.expanduser(confpath)
        self.conf = confparser(
                default_section="general",
                defaults=_DEFAULT_CONFIG)
        self.config_changed = False
        self.parse_config(self.confpath, conf=self.conf)

        # Repo configuration
        self.repo_path = os.path.expanduser(self.conf.get("general",
                                                           "repo_list"))
        self.log.debug("repo file: {}.".format(self.repo_path))
        self.repo_conf = self.parse_config(self.repo_path)
        self.repos = self.repo_conf.sections()
        self.repo_conf_changed = False
        self.log.debug("Repoplist {}".format(self.repo_conf.sections()))
        self.updated = {}

        # Used for temporary dir
        self.tmpdir = None

    def get_log(self, name, level):
        # Get root logger,
        # change its name to something other than root.
        log = logging.getLogger()
        log.name = name
        log.setLevel(level)

        # Create handlers and their formatters
        sth = logging.StreamHandler()
        stf = logging.Formatter("{name}: {message}", style='{')
        sth.setFormatter(stf)

        # Add handlers to log
        log.addHandler(sth)

        # Set handlers to DEBUG
        sth.setLevel(level)

        return log

    def parse_config(self, path,conf=None):
        """ Read a configuration from file

        Arguments:
        path: String or Path object to the file.
        """

        self.log.debug("Parsing conf in {}.".format(path))
        if not conf:
            conf = confparser()

        # Read configuration from file
        read_config = conf.read(os.path.expanduser(path))
        if not read_config:
            self.log.warning("Found no or empty configuration file.")

        return conf

    def get_tmpdir(self):
        if not self.tmpdir:
            self.tmpdir = tempfile.mkdtemp(prefix="gitcheckver-")

        return self.tmpdir

    def check_versions(self):

        self.log.info("Fetching versions for:")
        # Remember the parent logger
        old_log = self.log

        # Get the longest repo name for log padding later
        longest_repo_name = 0
        for repo_name in self.repos:
            if len(repo_name) > longest_repo_name:
                longest_repo_name = len(repo_name)

        # +1 so that even the longest repo name gets one space.
        longest_repo_name += 1

        # Handle all repos
        for repo in self.repos:
            # Get child logger
            self.log = old_log.getChild(repo)

            # Update repo
            repo_name = repo
            repo_url = self.repo_conf.get(repo_name, 'url')
            repo_path = self.repo_conf.get(repo_name, 'path', fallback=None)
            if not repo_path:
                repo_path = os.path.join(self.get_tmpdir(), repo_name)

            repo = self.update_repo(repo_url,
                                    os.path.expanduser(repo_path))

            # Print status for this repo
            padding = longest_repo_name - len(repo_name)
            if repo:
                msg = "Done."
            else:
                msg = "Error."

            self.log.info("{:>{padding}}"
                          .format(
                              msg,
                              # add the length of the message,
                              # this ligns up "Done" and the longer "Error"
                              padding=((padding)+len(msg))))
            try:
                old_ver = self.repo_conf.get(repo_name, 'ver', fallback="0.0")
                new_ver, repo_ver = self.check_version(repo,
                                                       old_ver,
                                                       repo_name)
                if (new_ver):
                    self.updated[repo_name] = repo_ver
            except Exception:
                pass

        self.log = old_log
        self.notify_updated()

    def update_repo(self, repo_url, repo_path=None):

        if(os.path.exists(repo_path)):
            repo_path = pygit2.discover_repository(repo_path)
            if(repo_path):
                repo = pygit2.Repository(repo_path)
                self.log.debug("Found local repo for {}"
                               .format(repo_url))
            try:
                for remote in repo.remotes:
                    remote.fetch(callbacks=self.BreakCallbacks())

            except NotImplementedError as e:
                self.log.debug("Couldn't update remote {}."
                                 .format(remote.name))
                self.log.debug("'{}: {}'".format(type(e).__name__,
                                                 e))
                pass
            except Exception as e:
                self.log.debug("Couldn't update remote {}."
                                 .format(remote.name))
                self.log.debug("'{}: {}'".format(type(e).__name__,
                                                 e))
                repo = None
        else:
            try:
                repo = pygit2.clone_repository(repo_url,
                                               repo_path,
                                               bare=True)
                self.log.debug("Cloned a copy of {}".format(repo_url))
            except Exception as e:
                self.log.debug("Couldn't update repo.")
                self.log.debug("'{}: {}'".format(type(e).__name__, e))
                repo = None

        return repo

    class BreakCallbacks(pygit2.RemoteCallbacks):
        def credentials(self, url, username_from_url, allowed_types):
            # TODO: implement actual authentication
            # see https://github.com/libgit2/pygit2/issues/428
            # and http://www.pygit2.org/remotes.html?highlight=credentials#credentials
            raise NotImplementedError(
                    "Authentication is not yet supported.")

    def check_version(self, repo, old_ver, repo_name):
        tag_regex = re.compile('^refs/tags/')
        tags = filter(lambda r: tag_regex.match(r),
                      repo.listall_references())
        repo_ver = re.sub(tag_regex, '', max(tags))

        if(repo_ver > old_ver):
            self.repo_conf.set(repo_name, 'ver', repo_ver)
            self.repo_conf_changed = True
            return True, repo_ver
        else:
            return False, None

    def notify_updated(self):
        if self.updated.items():
            for repo, version in self.updated.items():
                self.log.info("{} was updated to {}".format(repo, version))
        else:
            self.log.info("No new versions found.")

    def close(self):
        if(self.config_changed):
            self.save_config(self.confpath, self.conf)
        if(self.repo_conf_changed):
            self.save_config(self.repo_path, self.repo_conf)
        if(self.tmpdir):
            shutil.rmtree(self.tmpdir)
        sys.exit(0)

    def save_config(self, path,conf):
        try:
            os.makedirs(os.path.dirname(path), exist_ok=True)
            with open(path, 'w') as configfile:
                conf.write(configfile)
                self.log.debug("Updated configuration file {}.".format(path))
        except Exception as e:
            self.log.error("Couldn't write the configuration file {}."
                    .format(path))
            self.log.error("'{}: {}'".format(type(e).__name__,
                                             e))


if __name__ == "__main__":
    """Run the program with its command line parameters.

    Possible Parameters:
    -v,-d: Run in verbose (print debug messages; off by default)
    -q, --quiet: Run silently (only print warnings/errors)
    """
    verbose_mode = logging.INFO
    verbose_changed = False
    if len(sys.argv) > 1:
        for arg in sys.argv[1:]:
            # run in verbose
            if arg == '-v' or arg == '-d':
                # can't run -v and -q together, take whichever comes first
                if not verbose_changed:
                    verbose_mode = logging.DEBUG
                    verbose_changed = True
                    print("Running verbose.")
                else:
                    pass

            # run silently
            elif arg == '-q' or arg == '-quiet':
                # can't run -v and -q together, take whichever comes first
                if not verbose_changed:
                    verbose_mode = logging.WARNING
                    verbose_changed = True
                else:
                    pass

            # default
            else:
                pass

    main = gitcheckver(confpath=_DEFAULT_PATH, verbose=verbose_mode)

    # Check the versions, then close.
    main.check_versions()
    main.close()

# vim: set ts=4 sw=4 et:
