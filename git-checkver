#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.

#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <https://www.gnu.org/licenses/>.

import sys
import os
import tempfile
import shutil
import re
import logging

try:
    from configparser import ConfigParser as confparser
except ImportError:
    from ConfigParser import ConfigParser as confparser

try:
    import pygit2
except:
    print("Could not find the pygit2 package")
    sys.exit(1)

_DEFAULT_PATH = os.path.expanduser("~/.gitcheckver/config")

_DEFAULT_CONFIG =     {
        "repo_list": "~/.gitcheckver/repolist.cfg"
    }

class gitcheckver(object):

    def __init__(self, confpath=_DEFAULT_PATH, verbose=logging.INFO):

        # initiate logging
        self.log = self.get_log("gitcheckver", verbose)

        # initiate and read configuration
        self.confpath = os.path.expanduser(confpath)
        self.conf = confparser(
                default_section="general",
                defaults=_DEFAULT_CONFIG)
        self.config_changed = False
        self.parse_config(self.confpath, conf=self.conf)

        # get list of repos
        self.log.debug("repo file: {}.".format(self.conf.get("general",
            "repo_list")))
        self.repo_conf = self.parse_config(self.conf.get("general",
                                                         "repo_list"))
        self.repos = self.repo_conf.sections()
        self.log.debug("Repoplist {}".format(self.repo_conf.sections()))

        # Used for temporary dir
        self.tmpdir = None

    def get_log(self, name, level):
        # Get root logger,
        # change its name to something other than root.
        log = logging.getLogger()
        log.name = name
        log.setLevel(level)

        # Create handlers and their formatters
        sth = logging.StreamHandler()
        stf = logging.Formatter("{name}: {message}", style='{')
        sth.setFormatter(stf)

        # Add handlers to log
        log.addHandler(sth)

        # Set handlers to DEBUG
        sth.setLevel(level)

        return log

    def parse_config(self, path,conf=None):
        """ Read a configuration from file

        Arguments:
        path: String or Path object to the file.
        """

        self.log.debug("Parsing conf in {}.".format(path))
        if not conf:
            conf = confparser()

        # Read configuration from file
        read_config = conf.read(os.path.expanduser(path))
        if not read_config:
            self.log.warning("Found no or empty configuration file.")

        self.log.debug("parse_config: {}".format(conf.sections()))

        return conf

    def get_tmpdir(self):
        if not self.tmpdir:
            self.tmpdir = tempfile.mkdtemp(prefix="gitcheckver-")

        return self.tmpdir

    def update_repo(self, repo_url, repo_path=None):

        class BreakCallbacks(pygit2.RemoteCallbacks):
            def credentials(self, url, username_from_url, allowed_types):
                # TODO: implement actual authentication
                # see https://github.com/libgit2/pygit2/issues/428
                # and http://www.pygit2.org/remotes.html?highlight=credentials#credentials
                raise NotImplementedError(
                        "Authentication is not yet supported.")

        if(os.path.exists(repo_path)):
            repo_path = pygit2.discover_repository(repo_path)
            if(repo_path):
                repo = pygit2.Repository(repo_path)
                self.log.debug("Found local repo for {}"
                               .format(repo_url))
            try:
                for remote in repo.remotes:
                    remote.fetch(callbacks=BreakCallbacks())

            except NotImplementedError as e:
                self.log.warning("Couldn't update remote {}."
                                 .format(remote.name))
                self.log.debug("'{}: {}'".format(type(e).__name__,
                                                 e))
                pass
            except Exception as e:
                self.log.warning("Couldn't update remote {}."
                                 .format(remote.name))
                self.log.debug("'{}: {}'".format(type(e).__name__,
                                                 e))
                repo = None
        else:
            try:
                repo = pygit2.clone_repository(repo_url,
                                               repo_path,
                                               bare=True)
                self.log.debug("Cloned a copy of {}".format(repo_url))
            except Exception as e:
                self.log.error("Couldn't update repo.")
                self.log.debug("'{}: {}'".format(type(e).__name__, e))
                repo = None

        return repo

    def check_versions(self):

        self.log.info("Fetching versions.")
        updated = {}
        old_log = self.log
        for repo in self.repos:
            self.log = old_log.getChild(repo)
            repo_name = repo
            repo_url = self.repo_conf.get(repo_name, 'url')
            repo_path = self.repo_conf.get(repo_name, 'path', fallback=None)
            if not repo_path:
                repo_path = os.path.join(self.get_tmpdir(), repo_name)

            repo = self.update_repo(repo_url,
                                    os.path.expanduser(repo_path))

            if repo:
                self.log.info("Fetched version.")
            try:
                old_ver = self.repo_conf.get(repo_name, 'ver', fallback="0.0")
                new_ver, repo_ver = self.check_version(repo,
                                                       old_ver,
                                                       repo_name)
                if (new_ver):
                    updated[repo_name] = repo_ver
            except Exception:
                pass

        self.log = old_log
        self.notify_updated(updated)

    def check_version(self, repo, old_ver, repo_name):
        tag_regex = re.compile('^refs/tags/')
        tags = filter(lambda r: tag_regex.match(r),
                      repo.listall_references())
        repo_ver = re.sub(tag_regex, '', max(tags))

        if(repo_ver > old_ver):
            self.conf.set(repo_name, 'ver', repo_ver)
            self.config_changed = True
            return True, repo_ver
        else:
            return False, None

    def notify_updated(self, updated_dict=dict()):
        if updated_dict.items():
            for repo, version in updated_dict.items():
                self.log.info("{} was updated to {}".format(repo, version))
        else:
            self.log.info("No new versions found.")

    def close(self):
        # TODO: check if file exists.
        if(self.config_changed):
            try:
                os.makedirs(os.path.dirname(self.confpath), exist_ok=True)
                with open(self.confpath, 'w') as configfile:
                    self.conf.write(configfile)
                self.log.debug("Updated configuration file.")
            except Exception as e:
                self.log.error("Couldn't write the configuration file.")
                self.log.error("'{}: {}'".format(type(e).__name__,
                                                 e))
        if(self.tmpdir):
            shutil.rmtree(self.tmpdir)
        sys.exit(0)


if __name__ == "__main__":
    """Run the program with its command line parameters.

    Possible Parameters:
    -v: Run in verbose (print debug messages; off by default)
    -q: Run silently (only print warnings/errors)
    """
    verbose_mode = logging.INFO
    verbose_changed = False
    if len(sys.argv) > 1:
        for arg in sys.argv[1:]:
            # run in verbose
            if arg == '-v':
                # can't run -v and -q together, take whichever comes first
                if not verbose_changed:
                    verbose_mode = logging.DEBUG
                    verbose_changed = True
                    print("Running verbose.")
                else:
                    pass

            # run silently
            elif arg == '-q':
                # can't run -v and -q together, take whichever comes first
                if not verbose_changed:
                    verbose_mode = logging.WARNING
                    verbose_changed = True
                else:
                    pass

            # default
            else:
                pass

    main = gitcheckver(confpath=_DEFAULT_PATH, verbose=verbose_mode)

    # Check the versions, then close.
    main.check_versions()
    main.close()

# vim: set ts=4 sw=4 et:
