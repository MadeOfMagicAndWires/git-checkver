#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <https://www.gnu.org/licenses/>.

import sys
import os
import tempfile
import shutil
import re
import logging
import logging.handlers

try:
    from configparser import ConfigParser as confparser
except ImportError:
    from ConfigParser import ConfigParser as confparser

try:
    import pygit2
except:
    print("Could not find the pygit2 package")
    sys.exit(1)

_DEFAULT_PATH = os.path.expanduser("~/.gitcheckver/config")

_DEFAULT_CONFIG = {
        "repo_list": "~/.gitcheckver/repolist.cfg",
    }

class gitcheckver(object):

    def __init__(self, confpath=_DEFAULT_PATH, verbose=logging.INFO):

        # initiate logging
        self.log = self.get_log("gitcheckver", verbose)

        # initiate and read general configuration
        self.confpath = os.path.expanduser(confpath)
        self.conf = confparser(
                default_section="general",
                defaults=_DEFAULT_CONFIG)
        self.config_changed = False
        self.parse_config(self.confpath, conf=self.conf)
        self.add_config_handlers(self.conf)

        # Repo configuration
        self.repo_path = os.path.expanduser(self.conf.get("general",
                                                           "repo_list"))
        self.log.debug("repo file: {}.".format(self.repo_path))
        self.repo_conf = self.parse_config(self.repo_path)
        self.repos = self.repo_conf.sections()
        self.repo_conf_changed = False
        self.log.debug("Repoplist:")
        for each in self.repos:
            self.log.debug("{}".format(each))
        self.updated = {}

        # Used for temporary dir
        self.tmpdir = None

    def get_log(self, name, level):
        # Get root logger,
        # change its name to something other than root.
        log = logging.getLogger()
        log.name = name
        log.setLevel(logging.DEBUG)

        # Create handlers and their formatters ###############################
        # /dev/stdout
        sth = logging.StreamHandler()
        stf = logging.Formatter("{name}: {message}", style='{')
        sth.setFormatter(stf)

        # Add handlers to log
        log.addHandler(sth)

        # Set handler levels
        sth.setLevel(level)

        return log

    def parse_config(self, path,conf=None):
        """ Read a configuration from file

        Arguments:
        path: String or Path object to the file.
        """

        self.log.debug("Parsing conf in {}.".format(path))
        if not conf:
            conf = confparser()

        # Read configuration from file
        read_config = conf.read(os.path.expanduser(path))
        if not read_config:
            self.log.warning("Found no or empty configuration file.")

        return conf

    def add_config_handlers(self, conf=None):
        """Add extra logger handlers as the configuration dictates.

        :param conf: configparser object,
                     the configuration whose settings to read
         """

        # initiate empty variables
        lfh, emh = None, None

        # if logfile is set log to file
        if conf.has_option('general', 'logfile'):
            filep = os.path.expanduser(conf.get('general', 'logfile'))
            lfh = logging.handlers.RotatingFileHandler(
                   filep,
                   maxBytes=(1024*100),
                   backupCount=1,
                   delay=True)
            lff = logging.Formatter(
                    fmt="{asctime:.19} - {processName}: {message}",
                    style='{')

            lfh.setFormatter(lff)
            lfh.setLevel(logging.DEBUG)

        # if email settings are set, send log to email
        if conf.has_section('email') and conf.getboolean('general', 'email'):
            try:
                class BufferingSMTPHandler(logging.handlers.BufferingHandler):
                    """
                    Custom SMTP Handler that sends all log records in one email.

                    This is a hybrid between the Buffering and SMTP handler that
                    sends all records in one email instead of sending individual
                    emails for each logging message.

                    See https://gist.github.com/anonymous/1379446
                    """


                    def __init__(self,
                                 mailhost,
                                 fromaddr,
                                 toaddrs,
                                 subject,
                                 credentials=None,
                                 secure=None,
                                 timeout=5.0,
                                 capacity=0):
                        try:
                            super.__init__(self, capacity)
                        except:
                            logging.handlers.BufferingHandler.__init__(self, capacity)

                        # set from, to, and subject
                        self.fromaddr = fromaddr
                        self.toaddrs = toaddrs
                        self.subject = subject
                        # set host information
                        if isinstance(mailhost, (list, tuple)):
                            self.mailhost, self.mailport = mailhost
                        else:
                            self.mailhost, self.mailport = mailhost, None
                        # set credentials
                        if isinstance(credentials, (list, tuple)):
                            self.username, self.password = credentials
                        else:
                            self.username = None
                        # Set secure and timeout
                        self.secure = secure,
                        self.timeout = timeout

                        self.setFormatter(logging.Formatter("%(name)s: %(message)s"))

                    def flush(self):
                        if len(self.buffer) > 0:
                            try:
                                import smtplib
                                port = self.mailport
                                if not port:
                                    port = smtplib.SMTP_PORT
                                smtp = smtplib.SMTP(self.mailhost,
                                                    port,
                                                    timeout=self.timeout)
                                msg = "From: {0}\r\n"\
                                      "To:{1}\r\n"\
                                      "Subject:{2}\r\n\r\n"\
                                      .format(self.fromaddr,
                                              self.toaddrs,
                                              self.subject)

                                for record in self.buffer:
                                    s = self.format(record)
                                    msg = msg + s + "\r\n"

                                if self.username:
                                    if self.secure is not None:
                                        smtp.ehlo()
                                        smtp.starttls(*self.secure)
                                        smtp.ehlo()
                                    smtp.login(self.username, self.password)
                                smtp.sendmail(self.fromaddr, self.toaddrs, msg)
                                smtp.quit()
                            except:
                                self.handleError(None)  # no particular record
                            finally:
                                self.buffer = []
                        
                        def close(self):
                            """
                            Close the current handler *without* calling flush()

                            This way an email will only be sent if the logging
                            exceeds the buffer capacity or if flush() is called
                            manually
                            """
                            logging.Handler.close()


                # Transform some data to tuples
                host = (self.conf.get('email', 'server'),
                        self.conf.get('email', 'port'))
                cred = (self.conf.get('email', 'username'),
                        self.conf.get('email', 'password'))

                # Create handler, set level
                emh = BufferingSMTPHandler(
                        mailhost=host,
                        fromaddr=conf.get('email', 'from'),
                        toaddrs=conf.get('email', 'to'),
                        subject=conf.get('email', 'subject'),
                        credentials=cred,
                        secure=tuple(),
                        capacity=50)

                emh.setLevel(logging.INFO)
            except ImportError:
                pass

        if lfh:
            self.log.addHandler(lfh)
            self.logf = lfh
            self.log.debug("Using logfile {}".format(filep))
        if emh:
            self.log.addHandler(emh)
            self.email = emh
            self.log.debug("Sending email log to {}"
                    .format(conf.get('email', 'to')))

    def get_tmpdir(self):
        if not self.tmpdir:
            self.tmpdir = tempfile.mkdtemp(prefix="gitcheckver-")

        return self.tmpdir

    def check_versions(self):

        self.log.info("Fetching versions for:")
        # Remember the parent logger
        old_log = self.log

        # Get the longest repo name for log padding later
        longest_repo_name = 0
        for repo_name in self.repos:
            if len(repo_name) > longest_repo_name:
                longest_repo_name = len(repo_name)

        # +1 so that even the longest repo name gets one space.
        longest_repo_name += 1

        # Handle all repos
        for repo in self.repos:
            # Get child logger
            self.log = old_log.getChild(repo)

            # Update repo
            repo_name = repo
            repo_url = self.repo_conf.get(repo_name, 'url')
            repo_path = self.repo_conf.get(repo_name, 'path', fallback=None)
            if not repo_path:
                repo_path = os.path.join(self.get_tmpdir(), repo_name)

            repo = self.update_repo(repo_url,
                                    os.path.expanduser(repo_path))

            # Print status for this repo
            padding = longest_repo_name - len(repo_name)
            if repo:
                msg = "Done."
            else:
                msg = "Error."

            self.log.info("{:>{padding}}"
                          .format(
                              msg,
                              # add the length of the message,
                              # this ligns up "Done" and the longer "Error"
                              padding=(padding+len(msg))))
            try:
                old_ver = self.repo_conf.get(repo_name, 'ver', fallback="0.0")
                new_ver, repo_ver = self.check_version(repo,
                                                       old_ver,
                                                       repo_name)
                if (new_ver):
                    self.updated[repo_name] = repo_ver
            except Exception:
                pass

        self.log = old_log
        self.notify_updated()

    def update_repo(self, repo_url, repo_path=None):

        if(os.path.exists(repo_path)):
            repo_path = pygit2.discover_repository(repo_path)
            if(repo_path):
                repo = pygit2.Repository(repo_path)
                self.log.debug("Found local repo for {}"
                               .format(repo_url))
            try:
                for remote in repo.remotes:
                    remote.fetch(callbacks=self.BreakCallbacks())

            except NotImplementedError as e:
                self.log.debug("Couldn't update remote {}."
                                 .format(remote.name))
                self.log.debug("'{}: {}'".format(type(e).__name__,
                                                 e))
                pass
            except Exception as e:
                self.log.debug("Couldn't update remote {}."
                                 .format(remote.name))
                self.log.debug("'{}: {}'".format(type(e).__name__,
                                                 e))
                repo = None
        else:
            try:
                repo = pygit2.clone_repository(repo_url,
                                               repo_path,
                                               bare=True)
                self.log.debug("Cloned a copy of {}".format(repo_url))
            except Exception as e:
                self.log.debug("Couldn't update repo.")
                self.log.debug("'{}: {}'".format(type(e).__name__, e))
                repo = None

        return repo

    class BreakCallbacks(pygit2.RemoteCallbacks):
        def credentials(self, url, username_from_url, allowed_types):
            # TODO: implement actual authentication
            # see https://github.com/libgit2/pygit2/issues/428
            # and http://www.pygit2.org/remotes.html?highlight=credentials#credentials
            raise NotImplementedError(
                    "Authentication is not yet supported.")

    def check_version(self, repo, old_ver, repo_name):
        tag_regex = re.compile('^refs/tags/')
        tags = filter(lambda r: tag_regex.match(r),
                      repo.listall_references())
        repo_ver = re.sub(tag_regex, '', max(tags))

        if(repo_ver > old_ver):
            self.repo_conf.set(repo_name, 'ver', repo_ver)
            self.repo_conf_changed = True
            return True, repo_ver
        else:
            return False, None

    def notify_updated(self):
        if self.updated.items():
            for repo, version in self.updated.items():
                self.log.info("{} was updated to {}".format(repo, version))
            self.email.flush()
        else:
            self.log.info("No new versions found.")

    def close(self):
        # Update general config if needed
        if self.config_changed:
            self.save_config(self.confpath, self.conf)
        # Update repolist config if needed
        if self.repo_conf_changed:
            self.save_config(self.repo_path, self.repo_conf)
        # Remove temporary dir if needed
        if self.tmpdir:
            shutil.rmtree(self.tmpdir)
        # Close loggers
        logging.shutdown()
        sys.exit(0)

    def save_config(self, path,conf):
        try:
            os.makedirs(os.path.dirname(path), exist_ok=True)
            with open(path, 'w') as configfile:
                conf.write(configfile)
                self.log.debug("Updated configuration file {}.".format(path))
        except Exception as e:
            self.log.error("Couldn't write the configuration file {}."
                    .format(path))
            self.log.error("'{}: {}'".format(type(e).__name__,
                                             e))


if __name__ == "__main__":
    """Run the program with its command line parameters.

    Possible Parameters:
    -v,-d: Run in verbose (print debug messages; off by default)
    -q, --quiet: Run silently (only print warnings/errors)
    """
    verbose_mode = logging.INFO
    verbose_changed = False
    if len(sys.argv) > 1:
        for arg in sys.argv[1:]:
            # run in verbose
            if arg == '-v' or arg == '-d':
                # can't run -v and -q together, take whichever comes first
                if not verbose_changed:
                    verbose_mode = logging.DEBUG
                    verbose_changed = True
                    print("Running verbose.")
                else:
                    pass

            # run silently
            elif arg == '-q' or arg == '-quiet':
                # can't run -v and -q together, take whichever comes first
                if not verbose_changed:
                    verbose_mode = logging.WARNING
                    verbose_changed = True
                else:
                    pass

            # default
            else:
                pass

    main = gitcheckver(confpath=_DEFAULT_PATH, verbose=verbose_mode)

    # Check the versions, then close.
    main.check_versions()
    main.close()

# vim: set ts=4 sw=4 et:
